# Реализация анализа окон цепочек занятий (Chain Window Analysis)

## Обзор

Данная реализация решает проблему некорректного анализа пар занятий внутри одной цепочки при использовании системы `effective_bounds`. Проблема заключалась в том, что для поздних звеньев цепи нижние границы `min_time` "подрезались" (drift), и упрощённая проверка пересечения окон начинала ложно считать, что внутри-цепочные пары невозможны.

## Ключевые концепции

### 1. Окно цепочки (Chain Window)

**Определение**: Общее временное окно для всей цепочки занятий, вычисляемое как пересечение оригинальных временных окон всех членов цепи.

**Формула**:
```
min_chain = max(orig_min_time для всех C в цепи)
max_chain = min(orig_max_time для всех C в цепи)
```

### 2. Оригинальные границы (Original Time Bounds)

В отличие от `effective_bounds`, которые модифицируются ограничениями цепочки, оригинальные границы берутся непосредственно из полей `start_time` и `end_time` класса занятия:

- **Для временного окна**: `(start_time, end_time)`
- **Для фиксированного времени**: `(start_time, start_time)`
- **Для занятий без временных ограничений**: `(None, None)`

## Архитектура решения

### Модульная структура

1. **`linked_chain_utils.py`** - Основные утилиты для работы с цепочками
2. **`sequential_scheduling.py`** - Парный анализ занятий с поддержкой логики цепочек
3. **`resource_constraints.py`** - Анализ ресурсных конфликтов с учетом окон цепочек

### Ключевые функции

#### `get_chain_window(optimizer, chain_indices)`
Вычисляет общее временное окно для цепочки занятий.

**Возвращает**:
```python
{
    'min_time': str,      # "HH:MM"
    'max_time': str,      # "HH:MM" 
    'min_minutes': int,   # минуты от начала дня
    'max_minutes': int    # минуты от начала дня
}
```

#### `are_classes_in_same_chain(optimizer, idx1, idx2)`
Проверяет, принадлежат ли два занятия одной цепочке.

#### `analyze_same_chain_classes(optimizer, c1, c2, idx1, idx2, chain_indices)`
Анализирует возможность последовательного размещения двух занятий внутри одной цепочки, используя окно цепочки.

## Логика принятия решений

### Модифицированный алгоритм `can_schedule_sequentially`

```
1. Проверить одинаковый день
2. ЕСЛИ занятия в одной цепочке:
   - Использовать analyze_same_chain_classes()
   - Применить логику окна цепочки
3. ИНАЧЕ:
   - Использовать стандартную логику effective_bounds
   - Применить парный анализ временных окон
```

### Логика анализа окна цепочки

```
1. Получить окно цепочки
2. Рассчитать требуемое время = duration1 + duration2 + min_gap
3. Рассчитать доступное время = max_chain - min_chain
4. ЕСЛИ доступное_время >= требуемое_время:
   - РЕЗУЛЬТАТ: можно разместить последовательно
5. ИНАЧЕ:
   - РЕЗУЛЬТАТ: нельзя разместить последовательно
```

## Примеры использования

### Пример 1: Цепочка с пересекающимися окнами

```python
# Занятия цепочки
class1: Math    (08:00-12:00, 45 мин)
class2: Physics (09:00-11:00, 45 мин) 
class3: Chem    (09:30-10:30, 45 мин)

# Окно цепочки: max(08:00, 09:00, 09:30) - min(12:00, 11:00, 10:30)
# Результат: 09:30-10:30 (60 минут)

# Анализ пары (class1, class2):
# Требуемое время: 45 + 45 = 90 минут
# Доступное время: 60 минут
# Результат: НЕЛЬЗЯ разместить последовательно
```

### Пример 2: Цепочка с достаточным окном

```python
# Занятия цепочки
class1: Math    (08:00-12:00, 45 мин)
class2: Physics (08:30-11:30, 45 мин)

# Окно цепочки: max(08:00, 08:30) - min(12:00, 11:30)
# Результат: 08:30-11:30 (180 минут)

# Анализ пары (class1, class2):
# Требуемое время: 45 + 45 = 90 минут
# Доступное время: 180 минут  
# Результат: МОЖНО разместить последовательно
```

## Интеграция с существующей системой

### Модифицированные файлы

1. **`sequential_scheduling.py`**:
   - Добавлена проверка принадлежности к цепочке перед анализом effective_bounds
   - Добавлена функция `analyze_same_chain_classes()`

2. **`linked_chain_utils.py`**:
   - Добавлены функции работы с окнами цепочек
   - Добавлено кеширование результатов вычислений

3. **`resource_constraints.py`**:
   - Модифицирована функция `times_overlap()` для использования окон цепочек

### Обратная совместимость

Все изменения полностью обратно совместимы:

- Функции с новой логикой автоматически определяют принадлежность к цепочке
- При отсутствии цепочек используется исходная логика
- Fallback механизмы обеспечивают работу со старыми данными

## Тестирование

### Покрытие тестами

Создан комплексный набор тестов в `test_chain_window_analysis.py`:

1. **Модульные тесты**:
   - `test_get_original_time_bounds()` - получение оригинальных границ
   - `test_get_chain_window_success()` - успешное вычисление окна цепочки
   - `test_get_chain_window_no_intersection()` - обработка отсутствия пересечения

2. **Интеграционные тесты**:
   - `test_can_schedule_sequentially_with_chain_logic()` - основная функция
   - `test_realistic_chain_scenario()` - реалистичный сценарий

3. **Краевые случаи**:
   - Цепочки с занятиями без временных окон
   - Непересекающиеся окна в цепочке
   - Кеширование результатов

### Результаты тестирования

```
Ran 12 tests in 0.007s
OK
```

Все тесты проходят успешно, подтверждая корректность реализации.

## Производительность

### Оптимизации

1. **Кеширование**: Результаты вычисления окон цепочек кешируются для избежания повторных вычислений
2. **Ранний выход**: Проверка принадлежности к цепочке происходит до более дорогих операций
3. **Минимальные изменения**: Код добавляет логику, не нарушая существующие оптимизации

### Сложность

- **Вычисление окна цепочки**: O(n), где n - размер цепочки
- **Проверка принадлежности**: O(c), где c - количество цепочек  
- **Кеширование**: O(1) для повторных запросов

## Заключение

Реализация успешно решает проблему анализа пар занятий внутри цепочек, обеспечивая:

✅ **Корректность** - устраняет ложные конфликты внутри цепочек  
✅ **Производительность** - минимальные накладные расходы благодаря кешированию  
✅ **Совместимость** - полная обратная совместимость с существующим кодом  
✅ **Тестируемость** - комплексное покрытие тестами всех сценариев  
✅ **Читаемость** - четкое разделение логики и документированные функции
